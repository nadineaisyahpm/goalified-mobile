# Jawaban Pertanyaan Tugas 7 PBP

## 1. Apa itu Widget Tree pada Flutter dan bagaimana hubungan parent-child bekerja antar widget
Widget tree adalah susunan hierarki dari seluruh widget yang membentuk tampilan aplikasi Flutter. Setiap widget akan menjadi bagian dari pohon tersebut, mulai dari widget paling atas hingga elemen kecil di dalamnya. Dalam hubungan parent‑child, widget parent bertanggung jawab memberikan batas ukuran dan tata letak kepada widget child. Child lalu menentukan ukurannya berdasarkan batas tersebut, dan parent menempatkannya sesuai layout. Hierarki ini memastikan struktur UI tetap rapi serta memudahkan update tampilan ketika terjadi perubahan pada widget tertentu.

## 2. Sebutkan semua widget yang kamu gunakan dalam proyek ini dan jelaskan fungsinya
Contoh widget yang digunakan dalam proyek ini antara lain: MaterialApp untuk mengatur tema dan navigasi aplikasi, Scaffold sebagai struktur dasar halaman, serta AppBar untuk menampilkan judul di bagian atas. Widget seperti Column, Row, dan Container digunakan untuk menyusun tampilan serta memberikan ruang atau dekorasi. Selain itu, terdapat widget interaktif seperti ElevatedButton untuk aksi pengguna dan TextField untuk input data. Masing‑masing widget memiliki fungsi spesifik sehingga UI dapat dibangun secara terstruktur.

## 3. Apa fungsi dari widget MaterialApp? Mengapa widget ini sering digunakan sebagai widget root?
MaterialApp berfungsi sebagai konfigurasi utama aplikasi yang menggunakan Material Design, seperti tema, navigasi antar halaman, dan pengaturan tampilan dasar lainnya. Dengan menempatkan MaterialApp sebagai widget root, seluruh widget di dalam aplikasi mendapatkan akses terhadap fitur‑fitur ini. Hal ini memudahkan pengelolaan navigasi dan konsistensi gaya UI di seluruh halaman aplikasi, sehingga MaterialApp hampir selalu digunakan pada tingkat paling atas aplikasi Flutter.

## 4. Jelaskan perbedaan antara StatelessWidget dan StatefulWidget. Kapan kamu memilih salah satunya?
StatelessWidget digunakan ketika tampilan tidak bergantung pada perubahan data, sehingga sekali dibuat tampilannya akan tetap. Sebaliknya, StatefulWidget digunakan ketika tampilan harus berubah menyesuaikan interaksi atau data baru, misalnya ketika ada input pengguna atau animasi. Pemilihan widget bergantung pada apakah widget tersebut membutuhkan penyimpanan state atau tidak. Jika UI selalu sama dan hanya menerima data dari luar, gunakan StatelessWidget; tetapi jika perlu memperbarui tampilan berdasarkan perubahan internal, gunakan StatefulWidget.

## 5. Apa itu BuildContext dan mengapa penting di Flutter? Bagaimana penggunaannya di metode build?
BuildContext adalah objek yang menunjukkan posisi suatu widget di dalam widget tree. Dengan context, widget bisa mengakses informasi dari parent‑nya seperti ukuran layar, tema, navigasi, dan data yang diwariskan widget lain. Dalam metode build, context digunakan untuk memanggil berbagai fungsi seperti Theme.of(context) atau Navigator.of(context) agar tampilan dapat beradaptasi dengan lingkungannya. Karena itu, BuildContext sangat penting dalam membangun UI yang dinamis dan terhubung dengan struktur aplikasi.

## 6. Jelaskan konsep "hot reload" di Flutter dan bagaimana bedanya dengan "hot restart"
Hot reload memungkinkan pengembang melihat perubahan kode secara langsung tanpa kehilangan state aplikasi, sehingga proses pengembangan menjadi jauh lebih cepat. Berbeda dengan itu, hot restart akan memulai ulang aplikasi dari awal dan menghapus seluruh state yang sudah berjalan sebelumnya. Hot restart digunakan ketika perubahan kode memengaruhi bagian awal aplikasi, sedangkan hot reload cocok untuk perubahan UI dan logika ringan saat aplikasi sedang berjalan.

# Jawaban Pertanyaan Tugas 8 PBP

## 1. Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement() pada Flutter. Dalam kasus apa sebaiknya masing-masing digunakan pada aplikasi Football Shop kamu?
Navigator.push() menambahkan halaman baru ke atas stack navigasi, sehingga pengguna masih dapat kembali ke halaman sebelumnya dengan tombol back. Sementara itu, Navigator.pushReplacement() menggantikan halaman yang sedang ditampilkan dengan halaman baru, dan halaman sebelumnya dihapus dari stack sehingga tidak dapat kembali ke halaman semula.

Pada aplikasi Goalified, Navigator.push() cocok digunakan pada tombol Create Product di halaman utama, karena setelah selesai mengisi form, pengguna mungkin ingin kembali ke halaman Home. Sedangkan Navigator.pushReplacement() lebih tepat digunakan pada navigasi melalui Drawer, seperti saat berpindah ke halaman All Products atau My Products, agar halaman Home tidak menumpuk ketika melakukan navigasi berulang melalui menu samping.

## 2. Bagaimana kamu memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk membangun struktur halaman yang konsisten di seluruh aplikasi?
Saya menggunakan Scaffold sebagai struktur utama setiap halaman, yang menyediakan slot untuk AppBar, Drawer, dan body. AppBar digunakan untuk menampilkan branding aplikasi "Goalified." dengan warna, gaya teks, dan icon navigation yang seragam di semua halaman. Selain itu, Drawer digunakan sebagai navigasi global antar halaman sehingga pengalaman berpindah halaman terasa konsisten. Dengan hierarchy ini, semua halaman memiliki tampilan dan struktur UI yang seragam, sehingga pengguna mudah beradaptasi di seluruh bagian aplikasi.

## 3. Dalam konteks desain antarmuka, apa kelebihan menggunakan layout widget seperti Padding, SingleChildScrollView, dan ListView saat menampilkan elemen-elemen form? Berikan contoh penggunaannya dari aplikasi kamu.
- Widget seperti Padding, SingleChildScrollView, dan ListView mempermudah penataan form agar tetap nyaman digunakan:
- Padding menjaga jarak antar elemen sehingga form terlihat rapi dan tidak terlalu mepet satu sama lain.
- SingleChildScrollView membuat seluruh form dapat discroll ketika tinggi konten lebih besar dari layar, mencegah overflow saat keyboard muncul.
- ListView atau Column digunakan untuk menata input secara vertikal sehingga pengguna dapat mengisi data dengan alur yang jelas.

Contohnya pada halaman Create Product, input seperti nama produk, harga, deskripsi, dan tombol submit dibungkus Padding untuk memberi ruang, serta ditempatkan dalam SingleChildScrollView agar seluruh elemen tetap bisa diakses pada layar kecil.

## 4. Bagaimana kamu menyesuaikan warna tema agar aplikasi Football Shop memiliki identitas visual yang konsisten dengan brand toko?
Saya menyesuaikan warna aplikasi agar mencerminkan brand Goalified, yaitu kesan sporty dan modern. Warna hitam digunakan sebagai warna utama AppBar untuk memberikan kesan bold, sementara warna pada setiap card item menu (biru, hijau, merah) membedakan kategori fitur tanpa menghilangkan kesan energik. Selain itu, warna ikon pada Drawer dan AppBar seperti hamburger menu juga diseragamkan menjadi putih untuk meningkatkan keterlihatan dan menjaga konsistensi desain. Penyesuaian ini membantu memperkuat identitas visual aplikasi sehingga terlihat profesional dan mudah dikenali.

# Jawaban Pertanyaan Tugas 8 PBP

## 1. Mengapa kita perlu membuat model Dart saat mengambil/mengirim data JSON? Apa konsekuensinya jika langsung memetakan Map<String, dynamic>?

Saat bekerja dengan data JSON dalam Flutter, penggunaan model Dart sangat penting karena membantu menjaga struktur data tetap konsisten dan aman selama proses pengambilan maupun pengiriman data. Dengan membuat model, setiap field yang masuk akan memiliki tipe data yang jelas, sehingga compiler dapat melakukan pengecekan tipe (type checking) sebelum aplikasi dijalankan. Hal ini sangat bermanfaat dalam mencegah error runtime, terutama pada aplikasi yang bekerja dengan banyak endpoint atau data yang kompleks. Jika kita langsung bekerja dengan Map<String, dynamic> tanpa model, kita kehilangan sebagian besar perlindungan null-safety yang disediakan oleh Dart. Kesalahan seperti salah ketik nama key, field yang hilang, atau tipe yang tidak sesuai baru akan muncul saat runtime dan menyebabkan crash. Selain itu, tanpa model proses maintainability menjadi lebih sulit karena struktur data tidak terdokumentasi dengan jelas di dalam kode. Model juga membuat proses serialisasi dan deserialisasi lebih mudah, rapi, terorganisir, dan scalable ketika aplikasi semakin besar.

## 2. Apa fungsi package http dan CookieRequest dalam tugas ini? Jelaskan perbedaan peran http vs CookieRequest.

Package http berfungsi sebagai alat dasar untuk melakukan request ke server melalui HTTP, seperti GET dan POST. Package ini tidak menyimpan sesi atau cookie sehingga cocok untuk endpoint yang tidak membutuhkan autentikasi. Sementara itu, CookieRequest dari package pbp_django_auth dibuat khusus untuk aplikasi yang membutuhkan autentikasi Django. CookieRequest akan menyimpan cookie session Django secara otomatis dan mengirimkannya kembali pada setiap request berikutnya, sehingga server dapat mengenali user yang sedang login. Dengan kata lain, http melakukan komunikasi tanpa status (stateless), sedangkan CookieRequest menangani komunikasi berbasis sesi (stateful) yang diperlukan untuk login, whitelist endpoint, dan autorisasi user. Karena aplikasi ini membutuhkan login, filter item berdasarkan user, dan akses endpoint yang dilindungi, maka peran CookieRequest menjadi sangat penting.

## 3. Mengapa instance CookieRequest perlu dibagikan ke semua komponen di aplikasi Flutter?

Instance CookieRequest perlu dibagikan ke seluruh bagian aplikasi agar status autentikasi tetap konsisten di semua halaman. Setelah user login, server Django memberikan cookie sesi yang harus dikirim pada setiap request berikutnya. Jika setiap halaman membuat instance CookieRequest baru, maka cookie tidak akan terbawa dan server akan menganggap user belum login. Dengan membagikan instance yang sama melalui Provider, semua screen akan mendapatkan akses ke informasi autentikasi, status login, dan kemampuan melakukan request ke backend menggunakan sesi yang valid. Hal ini sangat penting untuk fitur seperti filter item berdasarkan user yang login, memposting data baru, logout, dan mengakses endpoint yang dilindungi. Tanpa single shared instance, aplikasi akan gagal menjaga state login dan menyebabkan user terus-menerus dianggap belum terautentikasi.

## 4. Jelaskan konfigurasi konektivitas antara Flutter dan Django. Mengapa perlu menambahkan 10.0.2.2 di ALLOWED_HOSTS, mengaktifkan CORS, SameSite/cookie, dan internet permission Android? Apa efek jika salah konfigurasi?

Agar Flutter dapat berkomunikasi dengan backend Django, beberapa konfigurasi sangat penting untuk memastikan request dapat diterima dan cookie dapat dikirim dari aplikasi mobile. Pertama, 10.0.2.2 harus ditambahkan ke ALLOWED_HOSTS karena ini adalah alamat khusus yang digunakan emulator Android untuk mengakses localhost komputer host. Tanpa ini, Django akan menolak request karena dianggap berasal dari host yang tidak diizinkan. Kedua, CORS perlu diaktifkan agar Django menerima request dari domain aplikasi mobile yang berbeda. Tanpa CORS, server akan menolak setiap request lintas domain. Ketiga, konfigurasi cookie seperti SameSite=None, Secure, dan pengaturan CSRF perlu disesuaikan agar cookie dapat terkirim dari aplikasi mobile; jika salah konfigurasi, login akan berhasil tetapi cookie tidak tersimpan, sehingga setiap request berikutnya tetap dianggap belum login. Terakhir, permission android.permission.INTERNET wajib ditambahkan pada manifest Android; tanpa izin ini, aplikasi mobile tidak dapat melakukan request ke server mana pun. Kesalahan pada salah satu konfigurasi ini akan menyebabkan aplikasi gagal login, gagal fetch JSON, atau backend menolak request.

## 5. Jelaskan mekanisme pengiriman data dari input hingga ditampilkan pada Flutter.

Proses pengiriman data dimulai saat user mengisi form pada Flutter, kemudian data tersebut dikumpulkan dan diserialisasi menjadi format JSON. Flutter mengirim JSON tersebut melalui POST request menggunakan CookieRequest (untuk endpoint yang dilindungi) atau http (untuk endpoint publik). Request ini diterima Django, kemudian diproses oleh view yang memvalidasi data dan menyimpannya pada database melalui model Django. Jika operasi berhasil, Django mengembalikan response JSON yang mengonfirmasi keberhasilan penyimpanan data. Ketika Flutter membutuhkan data untuk ditampilkan, aplikasi melakukan GET request ke endpoint JSON Django. Server merespon dengan data JSON berisi daftar item, lalu Flutter mendeserialisasi JSON ke model Dart untuk memastikan struktur dan tipe data konsisten. Setelah itu, data ditampilkan dalam bentuk UI seperti ListView, Card, atau halaman detail sesuai desain aplikasi.

## 6. Jelaskan mekanisme autentikasi dari login, register, hingga logout, mulai dari Flutter ke Django hingga tampilan menu.

Proses autentikasi dimulai saat user memasukkan username dan password pada Flutter. Ketika tombol login ditekan, Flutter mengirim data ini melalui CookieRequest.post ke endpoint /auth/login/ milik Django. Django kemudian memverifikasi kredensial menggunakan sistem autentikasi bawaan. Jika berhasil, Django membuat session dan mengembalikan cookie yang berisi session ID kepada Flutter. Cookie tersebut disimpan otomatis oleh CookieRequest, sehingga setiap request selanjutnya akan membawa informasi sesi yang valid. Setelah login sukses, Flutter membaca respons dan mengarahkan user ke halaman menu utama. Untuk proses registrasi, Flutter mengirim data form ke endpoint register Django yang kemudian membuat akun baru. Setelah terdaftar, user dapat login seperti biasa. Saat logout, Flutter memanggil endpoint /auth/logout/ dan Django akan menghapus sesi sehingga cookie tidak lagi valid. Flutter kemudian membersihkan state login dan mengarahkan user kembali ke halaman login.

## 7. Jelaskan bagaimana kamu mengimplementasikan seluruh checklist di atas secara step-by-step (bukan hanya mengikuti tutorial).

Saya memulai dengan memastikan deployment Django sudah berjalan stabil melalui Railway, termasuk memastikan endpoint JSON dapat diakses dari internet. Setelah itu, saya membuat model item kustom sesuai kebutuhan aplikasi, kemudian membuat serializer JSON untuk menampilkan semua atribut yang diperlukan seperti name, price, description, category, thumbnail, dan is_featured. Selanjutnya, saya mengimplementasikan halaman registrasi dan login pada Flutter, lalu menghubungkannya dengan endpoint autentikasi Django menggunakan CookieRequest. Setelah autentikasi bekerja, saya membuat halaman daftar item yang mengambil data dari endpoint JSON Django dan menampilkannya menggunakan model Dart untuk menjaga konsistensi tipe data. Saya juga menambahkan halaman detail item yang muncul saat card ditekan. Berikutnya, saya menambahkan fitur filter dengan cara memeriksa apakah item tersebut dimiliki oleh user yang sedang login. Setelah seluruh fitur selesai, saya melakukan styling dan penyesuaian UI agar konsisten secara visual, serta melakukan debugging untuk memastikan semua konfigurasi termasuk CORS, allowed hosts, dan cookie berfungsi dengan benar. Terakhir, saya menjawab semua pertanyaan dokumentasi pada README secara komprehensif untuk menjelaskan proses implementasi secara menyeluruh.